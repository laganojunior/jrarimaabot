#ifndef __JR_HASH_H__
#define __JR_HASH_H__

//hash table data structures to keep data for transpositions

#include "int64.h"
#include <assert.h>

//some constant defines
#define HASH_LOCK_BITS 17 //number of extra bits in the hash entry

class HashTableEntry
{
    //data is packed into a 64 bit integer as follows:
    //bit 0     : set to 1 if this hash has been already been filled with 
    //            score data
    //bit 1     : set to 1 if this hash has been filled for history purposes
    //bit 2-17  : 16 bits to store the upper bound of the score
    //bit 18-33 : 16 bits to store the lower bound of the score
    //bit 34-41 : index of the combo in the array returned by genMoves() that
    //            either is the best move from this node, or caused a beta
    //            cutoff
    //bit 42-46 : the depth this board was evaluated to
    //bit 47-63 : extra bits used to differentiate between boards that map
    //            to the same hash key

    public:
    //inline functions////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////
    //returns true if this entry has score data, which implies it should have
    //some sort of data on a move also
    //////////////////////////////////////////////////////////////////////////
    bool hasScores()
    {
        return data & 0x1;
    }

    //////////////////////////////////////////////////////////////////////////
    //returns true if this entry is part of the history of positions occuring
    //at the end of turns
    //////////////////////////////////////////////////////////////////////////
    bool isHistory()
    {
        return data & 0x2;
    }

    //////////////////////////////////////////////////////////////////////////
    //returns the upper bound of the score evaluated on this position
    //////////////////////////////////////////////////////////////////////////
    short getUpperBound()
    {
        return (data >> 2) & 0xFFFF;
    }

    //////////////////////////////////////////////////////////////////////////
    //returns the lower bound of the score evaluated on this position
    //////////////////////////////////////////////////////////////////////////
    short getLowerBound()
    {
        return (data >> 18) & 0xFFFF;
    }
    
    //////////////////////////////////////////////////////////////////////////
    //return the index of the combo (in respect to the array generated by
    //genMoves()) that is either the best move to take or a move that last
    //generated a beta cutoff
    //////////////////////////////////////////////////////////////////////////
    unsigned char getMoveIndex()
    {
        return (data >> 34) & 0xFF;
    }

    //////////////////////////////////////////////////////////////////////////
    //returns the depth the position was evaluated to
    //////////////////////////////////////////////////////////////////////////
    unsigned char getDepth()
    {
        return (data >> 42) & 0x1F;
    }

    //////////////////////////////////////////////////////////////////////////
    //returns the extra bits that contains basically another hash of the board
    //to differentiate positions that map to the same hashkey
    //////////////////////////////////////////////////////////////////////////
    Int64 getLock()
    {
        return (data >> 47);
    }

    //////////////////////////////////////////////////////////////////////////
    //Sets the data in this entry to some specified values
    //////////////////////////////////////////////////////////////////////////
    void set(bool scores, bool history, short upper, short lower, 
             unsigned char moveIndex, unsigned char depth, Int64 lock)
    {
        data = (scores & 0x1) | ((history & 0x1) << 1)
             | (((Int64)upper & 0xFFFF) << 2)
             | (((Int64)lower & 0xFFFF) << 18) | ((Int64)moveIndex << 34) 
             | (((Int64)depth & 0x1F) << 42) | (lock << 47);
    }

    private:
    Int64 data;
};

class HashTable //Note: This class is not copyable.
{
    public:
    HashTable(unsigned int numBits);
    ~HashTable();

    //inline functions////////////////////////////////////////////////////////
    
    //////////////////////////////////////////////////////////////////////////
    //returns a reference to the entry from the given hash key
    //////////////////////////////////////////////////////////////////////////
    HashTableEntry& getEntry(Int64 key)
    {
        assert (key < numEntries);

        return entries[key];
    }

    //////////////////////////////////////////////////////////////////////////
    //Sets the entry for the given hash key

    //////////////////////////////////////////////////////////////////////////
    void setEntry(Int64 key, HashTableEntry& entry)
    {
        assert (key < numEntries);
        entries[key] = entry;
    }

    HashTableEntry * entries; //array of entries in the hashtable
    Int64 numEntries;
};    

#endif
    
